install.packages
devtools::install_github("UM-Applied-Algorithms-Lab/PTMsToPathways")
?install.packages
install.packages('STRINGdb')
library('PTMsToPathways')
library(PTMsToPathways)
load("~/Desktop/PTMsToPathways/data/gm_edges.rda")
View(ex.gm.edges)
load("~/Desktop/PTMsToPathways/data/cfn.rda")
View(ex.cfn)
load("~/Desktop/PTMsToPathways/data/stringdb_edges.rda")
View(ex.stringdb.edges)
GetRtsne <- function(table, iter=5000){
if(!is.matrix(table)) table <- as.matrix(table) #Force parameter to be a matrix if it is not already
# Apply t-SNE to the distance matrix to reduce dimensions to 3 #
# Parameters: dims = 3 (3D output), perplexity = 15, theta = 0.25 (speed/accuracy trade-off) #
# max_iter = 5000 (number of iterations)
# check_duplicates = FALSE (treat rows as unique) #
# pca = FALSE (no initial PCA) #
return(Rtsne::Rtsne(table, dims = 3, perplexity = 15, theta = 0.25, max_iter = iter, check_duplicates = FALSE, pca = FALSE))
}
start_time <- Sys.time()
print("Starting correlation calculations and t-SNE.")
print(start_time)
print("This may take a few minutes for large data sets.")
#SPEARMAN CALCULATION
# Add if statement here to make sure functions are formatted correctly #
# Ensure ptmtable is a data frame with numeric values #
PTMnames <- sort(rownames(ptmtable))
load("~/Desktop/PTMsToPathways/data/ex_small_ptm_table.rda")
ptmtable <- ex_small_ptm_table
toolong =3
start_time <- Sys.time()
print("Starting correlation calculations and t-SNE.")
print(start_time)
print("This may take a few minutes for large data sets.")
#SPEARMAN CALCULATION
# Add if statement here to make sure functions are formatted correctly #
# Ensure ptmtable is a data frame with numeric values #
PTMnames <- sort(rownames(ptmtable))
ptmtable.sp <- apply(ptmtable, 1:2, as.numeric) #Exclude colnames from matrix and test to make sure they are numbers
# Calculate Spearman correlation #
ptm.correlation.matrix <- stats::cor(t(ptmtable.sp), use = "pairwise.complete.obs", method = "spearman")
# Note: this is the slowest step. We found  use = "pairwise.complete.obs", method = "spearman" to perform the best according to evaluations with data with missing values, but it takes longer.
# Replace diagonal with NA #
diag(ptm.correlation.matrix) <- NA
# Calculate dissimilarity #
sp.diss.matrix <- 1 - abs(ptm.correlation.matrix)
# Handle any remaining NA values by setting them to the maximum dissimilarity #
max.dist.sp <- max(sp.diss.matrix, na.rm = TRUE)
#Set NA values to 100 * the max distance
sp.diss.matrix[is.na(sp.diss.matrix)] <- 100 * max.dist.sp
# Fix names of correlation matrix
colnames(ptm.correlation.matrix) <- PTMnames
rownames(ptm.correlation.matrix) <- PTMnames
# Run t-SNE #
tsne.results <- GetRtsne(sp.diss.matrix) #Call GetRtsne
# Return t-SNE results #
spearman.cluster.coords = tsne.results$Y
#EUCLIDEAN CALCULATION
# Add if statement here to make sure functions are formatted correctly #
# Convert the dataframe to a distance matrix using Euclidean distance #
ptmtable.dist = as.matrix(stats::dist(ptmtable.sp, method = "euclidean"))
# Compute the maximum distance in the matrix, excluding NA values #
max.dist = max(ptmtable.dist, na.rm = TRUE)
# Replace NA values in the distance matrix with 100 times the maximum distance #
ptmtable.dist[is.na(ptmtable.dist)] <- 100 * max.dist
# Normalize the distance matrix by scaling it to a range from 0 to 100. This becomes the distance matrix for euclidian distance which we will run Rtsne on#
eu.dist.calc <- 100 * ptmtable.dist / max(ptmtable.dist, na.rm = TRUE)
eu.dist.calc <- as.matrix(eu.dist.calc) #Fix eu.dist.calc RQ
# Apply t-SNE to the distance matrix to reduce dimensions to 3 #
# Parameters: dims = 3 (3D output), perplexity = 15, theta = 0.25 (speed/accuracy trade-off) #
# max_iter = 5000 (number of iterations), check_duplicates = FALSE (treat rows as unique) #
# pca = FALSE (no initial PCA) #
eu.ptms.tsne.list <- GetRtsne(eu.dist.calc) #Call GetRtsne
# Extract the t-SNE results from the output list #
euclidean.cluster.coords <- eu.ptms.tsne.list$Y
#COMBINED CALCULATION
#fix spearman thing; so do the exact same thing but no absolute value
sp.diss.calc <- 1 - ptm.correlation.matrix            # range goes from (-1 to 1) to (0 to 2)
max.diss.sp <- max(sp.diss.calc, na.rm = TRUE)        # find the max value (around 2)
sp.diss.calc[is.na(sp.diss.calc)] <- 50 * max.diss.sp # Set every NA value to 50 * the max dissimilarity
sp.diss.calc <- as.matrix(sp.diss.calc)               # turn into a matrix
#find average
combined.distance <- (sp.diss.calc + eu.dist.calc) / 2
# Perform t-SNE on the combined distances #
tsne.result <- GetRtsne(combined.distance) #Call GetRtsne
sed.cluster.coords <- tsne.result$Y
#Nested function to analyze result
group <- NULL #Gets rid of check note
clustercreate <- function(result){
#Compute the minimum spanning tree connecting the points
tsne.span <- vegan::spantree(stats::dist(result), toolong=toolong)
#Find clusters that are connected based on toolong (distance?)
result.disc2 <-  vegan::distconnected(stats::dist(result), toolong = toolong, trace = FALSE)  # test
# cat ("threshold dissimilarity", toolong, "\n", max(result.disc2), " groups","\n")
#Create a plot of the clusters using vegan
vegan::ordiplot(result)
#lines(tsne.span, result) #???
vegan::ordihull(result, result.disc2, col="red", lwd=2)
#Format a data frame
result.span.df <- data.frame(PTMnames)
result.span.df$group <- result.disc2 #Add groups found above to the data frame
#Convert data frame into a list of clusters (check doesn't like group but it's a column name)
result.span.list <- plyr::dlply(result.span.df, plyr::.(group))  # GROUP LIST  !
return(result.span.list)
end_time <- Sys.time()
print(end_time)
#calculate difference between start and end time
total_time <- end_time - start_time
print(noquote(paste("Total time: ", total_time, sep="")))
} #END of nested function
#Create all tsne coords data sturcture and give it names
all.tsne.coords <- list(euclidean.cluster.coords, spearman.cluster.coords, sed.cluster.coords)
names(all.tsne.coords) <- c("Euclidean", "Spearman", "SED")
clusters.list <- lapply(all.tsne.coords, clustercreate)
names(clusters.list) <- c("Euclidean", "Spearman", "SED")
View(all.tsne.coords)
test <- all.tsne.coords[[1]]
View(all.tsne.coords)
View(test)
?ordiplot
clustercreate <- function(result){
#Compute the minimum spanning tree connecting the points
tsne.span <- vegan::spantree(stats::dist(result), toolong=toolong)
#Find clusters that are connected based on toolong (distance?)
result.disc2 <-  vegan::distconnected(stats::dist(result), toolong = toolong, trace = FALSE)  # test
# cat ("threshold dissimilarity", toolong, "\n", max(result.disc2), " groups","\n")
#Create a plot of the clusters using vegan
vegan::ordiplot(result, display = c())
#lines(tsne.span, result) #???
vegan::ordihull(result, result.disc2, col="red", lwd=2)
#Format a data frame
result.span.df <- data.frame(PTMnames)
result.span.df$group <- result.disc2 #Add groups found above to the data frame
#Convert data frame into a list of clusters (check doesn't like group but it's a column name)
result.span.list <- plyr::dlply(result.span.df, plyr::.(group))  # GROUP LIST  !
return(result.span.list)
end_time <- Sys.time()
print(end_time)
#calculate difference between start and end time
total_time <- end_time - start_time
print(noquote(paste("Total time: ", total_time, sep="")))
} #END of nested function
start_time <- Sys.time()
print("Starting correlation calculations and t-SNE.")
print(start_time)
print("This may take a few minutes for large data sets.")
#SPEARMAN CALCULATION
# Add if statement here to make sure functions are formatted correctly #
# Ensure ptmtable is a data frame with numeric values #
PTMnames <- sort(rownames(ptmtable))
ptmtable.sp <- apply(ptmtable, 1:2, as.numeric) #Exclude colnames from matrix and test to make sure they are numbers
# Calculate Spearman correlation #
ptm.correlation.matrix <- stats::cor(t(ptmtable.sp), use = "pairwise.complete.obs", method = "spearman")
source("~/Desktop/PTMsToPathways/R/MakeClusterList.R")
MakeClusterList(ptmtable)
View(ptmtable)
MakeClusterList(ptmtable)
t <- MakeClusterList(ptmtable)
source("~/Desktop/PTMsToPathways/R/MakeClusterList.R")
source("~/Desktop/PTMsToPathways/R/MakeClusterList.R")
t <- MakeClusterList(ptmtable)
source("~/Desktop/PTMsToPathways/R/MakeClusterList.R")
source("~/Desktop/PTMsToPathways/R/MakeClusterList.R")
MakeClusterList.withwarning <- MakeClusterList <- function(ptmtable, keeplength = 2, toolong = 3.5){
start_time <- Sys.time()
print("Starting correlation calculations and t-SNE.")
print(start_time)
print("This may take a few minutes for large data sets.")
#SPEARMAN CALCULATION
# Add if statement here to make sure functions are formatted correctly #
# Ensure ptmtable is a data frame with numeric values #
PTMnames <- sort(rownames(ptmtable))
ptmtable.sp <- apply(ptmtable, 1:2, as.numeric) #Exclude colnames from matrix and test to make sure they are numbers
# Calculate Spearman correlation #
ptm.correlation.matrix <- stats::cor(t(ptmtable.sp), use = "pairwise.complete.obs", method = "spearman")
# Note: this is the slowest step. We found  use = "pairwise.complete.obs", method = "spearman" to perform the best according to evaluations with data with missing values, but it takes longer.
# Replace diagonal with NA #
diag(ptm.correlation.matrix) <- NA
# Calculate dissimilarity #
sp.diss.matrix <- 1 - abs(ptm.correlation.matrix)
# Handle any remaining NA values by setting them to the maximum dissimilarity #
max.dist.sp <- max(sp.diss.matrix, na.rm = TRUE)
#Set NA values to 100 * the max distance
sp.diss.matrix[is.na(sp.diss.matrix)] <- 100 * max.dist.sp
# Fix names of correlation matrix
colnames(ptm.correlation.matrix) <- PTMnames
rownames(ptm.correlation.matrix) <- PTMnames
# Run t-SNE #
tsne.results <- GetRtsne(sp.diss.matrix) #Call GetRtsne
# Return t-SNE results #
spearman.cluster.coords = tsne.results$Y
#EUCLIDEAN CALCULATION
# Add if statement here to make sure functions are formatted correctly #
# Convert the dataframe to a distance matrix using Euclidean distance #
ptmtable.dist = as.matrix(stats::dist(ptmtable.sp, method = "euclidean"))
# Compute the maximum distance in the matrix, excluding NA values #
max.dist = max(ptmtable.dist, na.rm = TRUE)
# Replace NA values in the distance matrix with 100 times the maximum distance #
ptmtable.dist[is.na(ptmtable.dist)] <- 100 * max.dist
# Normalize the distance matrix by scaling it to a range from 0 to 100. This becomes the distance matrix for euclidian distance which we will run Rtsne on#
eu.dist.calc <- 100 * ptmtable.dist / max(ptmtable.dist, na.rm = TRUE)
eu.dist.calc <- as.matrix(eu.dist.calc) #Fix eu.dist.calc RQ
# Apply t-SNE to the distance matrix to reduce dimensions to 3 #
# Parameters: dims = 3 (3D output), perplexity = 15, theta = 0.25 (speed/accuracy trade-off) #
# max_iter = 5000 (number of iterations), check_duplicates = FALSE (treat rows as unique) #
# pca = FALSE (no initial PCA) #
eu.ptms.tsne.list <- GetRtsne(eu.dist.calc) #Call GetRtsne
# Extract the t-SNE results from the output list #
euclidean.cluster.coords <- eu.ptms.tsne.list$Y
#COMBINED CALCULATION
#fix spearman thing; so do the exact same thing but no absolute value
sp.diss.calc <- 1 - ptm.correlation.matrix            # range goes from (-1 to 1) to (0 to 2)
max.diss.sp <- max(sp.diss.calc, na.rm = TRUE)        # find the max value (around 2)
sp.diss.calc[is.na(sp.diss.calc)] <- 50 * max.diss.sp # Set every NA value to 50 * the max dissimilarity
sp.diss.calc <- as.matrix(sp.diss.calc)               # turn into a matrix
#find average
combined.distance <- (sp.diss.calc + eu.dist.calc) / 2
# Perform t-SNE on the combined distances #
tsne.result <- GetRtsne(combined.distance) #Call GetRtsne
sed.cluster.coords <- tsne.result$Y
#Nested function to analyze result
group <- NULL #Gets rid of check note
clustercreate <- function(result){
#Compute the minimum spanning tree connecting the points
tsne.span <- vegan::spantree(stats::dist(result), toolong=toolong)
#Find clusters that are connected based on toolong (distance?)
result.disc2 <-  vegan::distconnected(stats::dist(result), toolong = toolong, trace = FALSE)  # test
# cat ("threshold dissimilarity", toolong, "\n", max(result.disc2), " groups","\n")
#Create a plot of the clusters using vegan
vegan::ordiplot(result)
#lines(tsne.span, result) #???
vegan::ordihull(result, result.disc2, col="red", lwd=2)
#Format a data frame
result.span.df <- data.frame(PTMnames)
result.span.df$group <- result.disc2 #Add groups found above to the data frame
#Convert data frame into a list of clusters (check doesn't like group but it's a column name)
result.span.list <- plyr::dlply(result.span.df, plyr::.(group))  # GROUP LIST  !
return(result.span.list)
end_time <- Sys.time()
print(end_time)
#calculate difference between start and end time
total_time <- end_time - start_time
print(noquote(paste("Total time: ", total_time, sep="")))
} #END of nested function
#Create all tsne coords data sturcture and give it names
all.tsne.coords <- list(euclidean.cluster.coords, spearman.cluster.coords, sed.cluster.coords)
names(all.tsne.coords) <- c("Euclidean", "Spearman", "SED")
clusters.list <- lapply(all.tsne.coords, clustercreate)
names(clusters.list) <- c("Euclidean", "Spearman", "SED")
FindCommonClusters <- function(clusters.list, keeplength=3) { # >>>> NEW method
# For each clustering method:
#   1.	Create a square matrix of all PTMs (across clusterings).
#  2.	For each cluster, set all PTM–PTM pairs in the cluster to 1 (indicating co-membership).
#  3.	The final matrix for a method has 1 for PTM pairs co-clustered at least once in that method; 0 otherwise.
#  clusters.list is the list of clusters from different embeddings: list(Euclidean, Spearman, SED) from MakeClusterList()
library(purrr)
start_time <- Sys.time()
message("Starting FindCommonClusters at ", start_time)
get_ptm_names <- function(clusters) {
unique(unlist(lapply(clusters, function(cl) cl$PTMnames)))
}
all_ptms <- unique(unlist(map(clusters.list, get_ptm_names)))
co_membership_matrix <- function(clusters, all_ptms) {
mat <- matrix(0, nrow = length(all_ptms), ncol = length(all_ptms),
dimnames = list(all_ptms, all_ptms))
for (cluster in clusters) {
ptms <- intersect(cluster$PTMnames, all_ptms)
if (length(ptms) > 1) {
mat[ptms, ptms] <- 1
}
}
diag(mat) <- 0
mat
}
adjacency_matrices <- purrr::map(clusters.list, co_membership_matrix, all_ptms=all_ptms)
# Step 2: Sum the Co-Membership Matrices Across Methods
adj.sum <- Reduce("+", adjacency_matrices)    # values: 0 (never), 1, 2, 3 (co-clustered in all 3 methods)
diag(adj.sum) <- 0
#Step 3: Build a Consensus Network (for Co-Clustering in All 3 Embeddings)
#	Edges: Only keep edges where `adj.sum == 3` (meaning the PTM pair is in the same cluster in all three methods).
adj.consensus <- (adj.sum == 3) * 1 # This is a neat R trick to convert a logical matrix (`TRUE`/`FALSE`) to a numeric matrix (`1`/`0`) via multiplication.
diag(adj.consensus) <- 0
g <- igraph::graph_from_adjacency_matrix(adj.consensus, mode="undirected", diag=FALSE)
# Step 4: Extract Cliques (Consensus Clusters)
# use `igraph` to extract maximal cliques, which are sets of PTMs such that every member is connected to every other member in all three methods.
clique_list <- igraph::max_cliques(g, min=2)  # Only consider cliques of at least size 2
clusters_in_all_three <- lapply(clique_list, function(v) igraph::V(g)[v]$name)
# Filter out very small cliques
clusters_in_all_three <- Filter(function(x) length(x) >= keeplength, clusters_in_all_three)
if (length(clusters_in_all_three) > 0) {
names(clusters_in_all_three) <- paste0("ConsensusCluster", seq_along(clusters_in_all_three))
} else {
warning("No cliques remain after filtering with keeplength = ", keeplength)
}
end_time <- Sys.time()
print(end_time)
#calculate difference between start and end time
total_time <- end_time - start_time
print(noquote(paste("Total time: ", total_time, sep="")))
return(list(adj.consensus, clusters_in_all_three))
}
#Find common clusters
clusters.common.list <- FindCommonClusters(clusters.list, keeplength) # Runtime: 10 seconds
adj.consensus <- clusters.common.list[[1]]
common.clusters <- clusters.common.list[[2]]
return(list(common.clusters, adj.consensus, ptm.correlation.matrix))
}
set.seed(1)
t1 <- MakeClusterList(ptmtable)
set.seed(1)
t2 <- MakeClusterList.withwarning(ptmtable)
result <- identical(t1, t2) #should return TRUE
result
source("~/Desktop/PTMsToPathways/R/MakeClusterList.R")
set.seed(1)
t1 <- MakeClusterList(ptmtable)
set.seed(1)
t2 <- MakeClusterList.witherror(ptmtable)
View(MakeClusterList.withwarning)
set.seed(1)
t1 <- MakeClusterList(ptmtable)
set.seed(1)
t2 <- MakeClusterList.withwarning(ptmtable)
result <- identical(t1, t2)
result
identical(t1[[1]], t2[[1]])
identical(t1[[2]], t2[[2]])
identical(t1[[3]], t2[[3]])
identical(t1[[3]], t2[[2]])
View(t1[[2]])
View(t2[[2]])
library("PTMsToPathways")
setwd("PTMsToPathways")
devtools::document()
source("~/run.R")
View(ptmtable)
OutputMCL <- MakeClusterList(ptmtable[,1:9], 1, 1)
source("~/run.R")
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), ]
View(ptmtable)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 1:10]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 1:15]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
View(OutputMCL)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 1:13]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
value <- ptmtable
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 1:10]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 8:18]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 8:14]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 75), 8:14]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 8:14]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 8:12]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 100), 8:12]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 75), 8:12]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 100), 8:12]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 100), 8:10]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 75), 8:10]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 90), 8:10]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
ptmtable <- ex_small_ptm_table[sample(nrow(ex_small_ptm_table), 125), 8:14]
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
colSums(is.na(ptmtable))
colSums(is.na(ex_small_ptm_table))
force(ex_full_ptm_table)
force(ex_adj_consensus)
View(ex_full_ptm_table)
View(ex_small_ptm_table)
View(ex_full_ptm_table)
ex_full_ptm_table <- ex_full_ptm_table
rownames(ex_full_ptm_table) <- ex_full_ptm_table[,1]
t <- ex_full_ptm_table[,-1]
View(t)
ex_full_ptm_table <- t
View(ex_small_ptm_table)
setwd(
"data"
)
""
getwd()
save("ex_full_ptm_table", ex_full_ptm_table, file="ex_full_ptm_table.rda")
devtools::document()
load("~/PTMsToPathways/data/ex_full_ptm_table.rda")
View(ex_common_cluster)
View(ex_full_ptm_table)
load("~/PTMsToPathways/data/ex_full_ptm_table.rda")
View(ptmtable)
OutputMCL <- MakeClusterList(ptmtable, 1, 1)
View(ex_ptm_correlation_matrix)
View(OutputMCL)
ex_tiny_ptm_table <- ptmtable
getwd()
setwd("PTMsToPathways/data")
save("ex_tiny_ptm_table", ex_tiny_ptm_table, file="ex_tiny_ptm_table.rda")
source("~/run.R")
load("~/PTMsToPathways/data/ex_tiny_ptm_table.rda")
source("~/run.R")
View(ex_common_cluster)
View(ex_adj_consensus)
View(ex_ptm_cccn_g)
View(ex_gene_cccn_g)
View(ex_gene_cccn_edges)
View(OutputMCN)
View(ex_gene_cccn_edges)
View(ex_gene_cccn_g)
rownames(ex_gene_cccn_edges)
rownames(ex_gene_cccn_g)
View(ex_ptm_cccn_edges)
View(ex_ptm_cccn_g)
View(ex_gene_cccn_edges)
View(ex_gene_cccn_g)
View(ex_ptm_cccn_edges)
View(ex_ptm_cccn_g)
View(ex_ptm_cccn_edges)
View(ex_ptm_cccn_g)
View(ex_ptm_cccn_edges)
setwd("../..")
getwd()
source("~/run.R")
setwd("runpackage2")
source("~/runpackage2/run.R")
library("PTMsToPathways")
devtools::document("../PTMsToPathways")
source("~/runpackage2/run.R")
source("~/runpackage2/run.R")
